---
title: 'DV: HydraNight B'
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: 
        collapsed: false
    number_sections: true
    theme: readable
    highlight: zenburn
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      out.width = '100%')
options(scipen = 99)
library(lubridate)
```

# Day 1: The State of Trending Videos

In order to improve our company's brand awareness, we're working on a video content that later on will be published on YouTube. To improve efficiency of our video content, we're scraping a dataset from YouTube's US Trending Videos.

## Read data:

```{r}
vids <- read.csv("USvideos.csv")

names(vids)
```


## Take a glimpse of your data:

```{r}
str(vids)
```

Recall what you've learned in P4DS. Do the column `title` have stored in the correct class?

```{r}
vids$title <- as.character(vids$title)

str(vids)
```

## Working with date/time

Now in order to get the best engagement, we want to publish our video in the "perfectly right" time. Looking back to the structure of our dataset, there are two variables in our dataset which related to datetime data; `trending_date` and `publish_date`.

Previously we've learned base R method to convert our column to date with `as.Date()` function, followed with your data time formatting (if your date data wasn't stored in ISO format;YYYY-MM-DD):

YEAR  
%Y = YYYY  
%y = YY   
  
MONTH  
%B = month name e.g. March  
%b = month name(abbreviation) e.g. Mar  
%m = 2 digits mo e.g. 03  
%M = 1 digit mo e.g. 3  
  
DAY  
%A = weekday e.g. Friday  
%d = weekday digit.

Let's start with `trending_date`. Following our previous knowledge, we'd convert our date variable with: `as.Date(vids$trending_date, "%y.%d.%m")`
  
But here, I’ll show you another way of working with dates, and that is through the use of `lubridate`

```{r}
# install.packages("lubridate")
library(lubridate)
```

`lubridate` provides tools that make it easier to parse and manipulate dates.

```{r}
a <- "08/03/19"
b <- "8-March-2019"
c <- "Thursday, 09-05-2019"
d <- "2019/05/09, 1:42PM"

as.Date(a, "%d/%m/%y")

dmy(a)
dmy(b)
dmy(c)

class(ymd_hm(d))

```

**Dive Deeper**: 

Apply what you've learned about lubridate to revert the `trending_date` & `publish_time` column in `vids`!

```{r}
vids$trending_date <- ydm(vids$trending_date)

tail(vids$trending_date)
head(vids$trending_date)
```

```{r}
vids$publish_time <-  ymd_hms(vids$publish_time,tz = "America/New_York")
head(vids$publish_time)

```

```{r}
head(vids)
```


* Hint: 
```{r}
head(vids$publish_time)
```

https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List


Now that we've converted our date column in the right classes, we can extract more information from our datetime data. Let's create another two variables, name `trending_dow` and `trending_month`, which stores the day and month of the video's trending date.

```{r}
# head(wday(vids$trending_date,
#           label = T,
#           abbr = F,
#           week_start = 1))

vids$trending_dow <- wday(vids$trending_date,
                           label = T,
                           abbr = F,
                           week_start = 1)

vids$trending_month <- month(vids$trending_date,
                             label = T)

head(vids$trending_month)
```

**In Class Question**:

- Language in lubridate

Table of locales:
https://docs.moodle.org/dev/Table_of_locales

```{r}
sessionInfo()

wday("2018-10-10", locale = "id_ID.UTF-8", label = T)
```

### if condition

**Dive Deeper**:  
1. Create a new variable named `publish_wday` which stores the day of the video's publish time!  
2. Create another named `publish_hour` which stores the hour of the video's publish time!  
3. Lastly, create a variable named `publish_when` which stores **period of the day** of the video's publish time! The period must follow these conditions:  
  - If the video published **before 8**, it's on **"12AM to 8AM"** publish period  
  - If the video published **between 8 and 16**, it's on **"8AM to 3PM"** publish period  
  - If the video published **after 16**, it's on **"3PM to 12AM"** publish period.  
  
  
Hint for number 3:  
1. Pass an If Statement, write it as a function, and then use `sapply` to apply the function to your new variable.  
If Statement example:  
```{r}
x <- 5

if (x < 0){
 print("Negative number")
}else if (x > 0){
print("Positive number")
}else  
print("Zero")

```

```{r}
# Your Answer Here

vids$publish_wday <- wday(vids$publish_time, label = T, abbr = F, week_start = 1)
vids$publish_hour <- hour(vids$publish_time)

# complete the following function:
pw <- function(x){
  if(x < 8){
    x <- "12AM to 7AM"
  }else if(x >= 8 & x < 16){
    x <- "8AM to 3PM"
  }else{
    x <- "4PM to 12AM"
  }
  
}

vids$publish_when <- as.factor(sapply(vids$publish_hour, pw))

head(vids$publish_wday)
```


## Working with categorical data: reordering factor levels

```{r}
levels(vids$publish_when)
```


```{r}
vids$publish_when <- ordered(vids$publish_when,
                             levels = c("12AM to 7AM",
                                        "8AM to 3PM",
                                        "3PM to 12AM"))

levels(vids$publish_when)
```


**In Class Question**: Reordering factor level:

- Reorder based on other values
```{r}
agg <- aggregate(likes ~ category_id, yt_trend, sum)
agg[order(agg$likes),]

levels(with(vids, reorder(category_id, likes)))
```

- Reorder with relevel:
```{r, eval=FALSE}
levels(relevel(yt_trend$category_id, "Gaming"))
```

3rd options:
library(forcats)


## Using lapply & sapply

### lapply

`lapply` can be a very useful tool to apply a function to multiple variables:

```{r}
str(vids)
```

```{r}
vids[ ,c("views", "likes", "dislikes", "comment_count") ] <- lapply(vids[ ,c("views", "likes", "dislikes", "comment_count") ] ,as.numeric)

str(vids)
```

### sapply

The raw dataset does not have the proper names for each category, but identify them by an “id” instead. The following code chunk use `sapply` to “switch” them by “id” and also convert that to a factor. 

Extra explanation on `switch()`:

```{r}
switch(1,
       "1" = "Low",
       "2" = "Medium",
       "3" = "High")

data <- 1:3

sapply(data, switch,
       "1" = "Low",
       "2" = "Medium",
       "3" = "High")

```

```{r}
vids$category_id <- sapply(as.character(vids$category_id), switch, 
                           "1" = "Film and Animation",
                           "2" = "Autos and Vehicles", 
                           "10" = "Music", 
                           "15" = "Pets and Animals", 
                           "17" = "Sports",
                           "19" = "Travel and Events", 
                           "20" = "Gaming", 
                           "22" = "People and Blogs", 
                           "23" = "Comedy",
                           "24" = "Entertainment", 
                           "25" = "News and Politics",
                           "26" = "Howto and Style", 
                           "27" = "Education",
                           "28" = "Science and Technology", 
                           "29" = "Nonprofit and Activism",
                           "43" = "Shows")

vids$category_id <- as.factor(vids$category_id)
```

`vids` has 13400 records of trending videos, but there are many videos that were trending for a few days and we really only have a collection of 2,986 unique videos. On a very broad average, each video was trending for ~4.5 days.

Let’s create a dataframe, call it `vids.u` that takes only the first observation of each `vids$title` within the data. `match` returns a vector of the positions of matches of its first argument in its second:

```{r}
length(unique(vids$title))
```

```{r}
table(vids$trending_date)
```

```{r}

# vids[order(vids$trending_date),]
vids.u <- vids[match(unique(vids$title), vids$title), ]
```

# Base Plotting/Statistical Plots

Statistical plots helps us visually inspect our dataset and there are numerous ways to achieve that in R. The simplest of which is through the `plot()`function. In the following code we create two vectors, x and y, and created a plot:

```{r}
plot(vids.u$category_id, vids.u$likes/vids.u$views)
```

Say, one of the content we want to publish have people who interested in "Autos and Vehicles", "Gaming", and "Travel and Events" as our target audience. So let's subset our data based on these particular categories:

```{r}
vids.agt <- vids.u[vids.u$category_id == "Autos and Vehicles" | 
                     vids.u$category_id == "Gaming" |
                     vids.u$category_id == "Travel and Events", ]
```

```{r}
vids.agt$likesp <- vids.agt$likes/vids.agt$views
vids.agt$dislikesp <- vids.agt$dislikes/vids.agt$views
```

`plot()` knows how to pick sensible defaults based on the input vector it was given. By passing exactly the same function, it gives you different visualization, adjusting to the type of datas you add. 

```{r}
plot(vids.agt$likesp, vids.agt$dislikesp,
     xlab = "Likes Ratio",
     ylab = "Dislikes Ratio",
     main = "Likes vs Dislikes Ratio")
```

We can also add extra features to our plot, such as adding line which shows the correlation between the `likes-to-view` and `dislikes-to-view` ratio and  a legend to show how the colors of our scatterplot points map to each level of our `category_id` variable.

```{r}
vids.agt$category_id <- factor(vids.agt$category_id)

plot(vids.agt$likesp, vids.agt$dislikesp,
     col=vids.agt$category_id, pch=19)
abline(lm(vids.agt$dislikesp ~ vids.agt$likesp),
       col="hotpink",lwd=3,lty=2)
legend("topright",
       legend=levels(vids.agt$category_id),
       fill=1:3)
```

Apart from using `plot()`, we can also create statistical plots using functions such as `hist()`. `hist()` takes a numeric vector and creates a histogram:

```{r}

```

We can additionally use the `breaks` argument to control the number of bins if we were not satisfied with the default values:

```{r}
hist(yt_trend.agt$likesp, breaks = 20, ylim = c(0,20), col = "dark blue", main = "Distribution of likes v view")
lines(density(yt_trend.agt$likesp))
```

Just like how we can add `abline` onto our plot, we can add graphical elements like `lines` onto this histogram too. In fact, let’s do that and also use the main argument to give our plot a new main title:

```{r}
```

While base plot can be very simple to use, they can be effective too. In fact, with the use of proper coloring, annotation and a little care on the aesthetic touches, you can communicate a lot in a graph using just R’s built-in plotting system.

In the following code chunk I’m subsetting from vids.agt only trending videos that have more than 10,000 likes and order it by the likes-to-view variable. I added a new variable, col to this new dataframe to be used in my following plot:

```{r}
yt_trend.ags <- yt_trend.agt[yt_trend.agt$likes > 10000, ]
yt_trend.ags <- yt_trend.ags[order(yt_trend.ags$likesp), ]

# comparing dot to hist
dotchart(yt_trend.ags$likesp)
hist(yt_trend.ags$likesp)

# add color variable
yt_trend.ags$col[yt_trend.ags$category_id == "Autos and Vehicles"] <- "goldenrod4"
yt_trend.ags$col[yt_trend.ags$category_id == "Gaming"] <- "dodgerblue4"
yt_trend.ags$col[yt_trend.ags$category_id == "Travel and Events"] <- "firebrick4"

dotchart(yt_trend.ags$likesp,
         labels=yt_trend.ags$channel_title, cex=.7, pch=19,
         groups=yt_trend.ags$category_id,
         col=yt_trend.ags$col)
```

Let’s talk about another kind of plot, one that most statisticians find cringeworthy for it’s undeserved popularity and prevalence in the workplace. Yes, it is the pie chart. In R’s official documentation, the pie chart is criticized as being “a very bad way of displaying information [because] the eye is good at judging linear measures and bad at judging relative areas”. 

Almost any data that can be represented in a pie chart can be illustrated with a bar chart.
If you insist on creating one, here’s the code (I’ve added some colors to make it easier to get a grasp of the measures):

```{r}
pie(table(yt_trend.agt$publish_hour))

pie(table(yt_trend.agt$publish_hour),
    labels=names(table(yt_trend.agt$publish_hour)),
    col=topo.colors(24))
```

# Grammar of Graphics in R

```{r}
# install.packages("ggplot2")
library(ggplot2)

# to load data to chart:
library(ggpubr)
library(png)
```

## Motivation of ggplot2: 

Let us take a look at a simple example, drawing inspiration from the Earthquake incident that happened in the south of Jakarta in 2018, I’ve created a dataframe called gempa:

```{r}
jak <- readPNG("jakarta.png")

gempa <- data.frame(
  x=c(3.5,3,4,4.5,4.1),
  y=c(12,14,12.4,12.5,14), 
  size=c(14,4,4,6,12)
)
gempa
```

```{r}
ggplot(data = gempa, aes(x = x, y = y)) + background_image(jak) + geom_point(size = gempa$size, color = "red")
```


# Hands-on: Simple Explanatory Analysis
```{r}
yt_trend.ags$commentp <- yt_trend.ags$comment_count/yt_trend.ags$views
ggplot(yt_trend.ags, aes(x = category_id, y = dislikes)) + geom_boxplot() + geom_jitter(aes(col = likesp, size = commentp)) + labs(title = "YouTube Trending Videos Engagement Analysis", subtitle = "Data From US Trending: 2017-11-4 to 2018-01-19") + theme(plot.title = element_text(hjust = .5))
```

# Simple Analysis: Best 'Ad-pocalypse maker'

```{r}
temp1 <- as.data.frame(table(Channel = yt_trend.u$channel_title))
temp1 <- temp1[temp1$Freq >= 10, ]
temp1 <- temp1[order(temp1$Freq, decreasing = T), ]
temp1

ggplot(temp1, aes(x = Channel, y = Freq)) + geom_col() + theme(axis.text.x = element_text(angle = 90))
```

```{r}
head3Temp <- head(temp1, 3)
tail8Temp <- tail(temp1, 8)
tempGG <- ggplot(temp1, aes(x = reorder(Channel, Freq), y = Freq)) +  geom_col(aes(fill = Freq)) + coord_flip() + labs(title = "Channel w/ Most Trending Videos", y = NULL, x = NULL, fill = "Number of Videos", caption = "'Bob or vagana, whichever will it be' - The #1 Youtuber ever exist") + scale_fill_continuous(high = "red", low = "dark blue") + scale_y_continuous(limits = c(0, 35), breaks = seq(0,30,5)) + geom_col(data = head3Temp, aes(fill = Freq), fill = "light blue") + theme(legend.position = "none") + theme(plot.title = element_text(hjust = .5, size = 16), plot.caption = element_text(face = "bold"))

top8Temp <- ggplot(head(temp1, 8), aes(x = reorder(Channel, Freq), y = Freq)) + geom_col(aes(fill = Freq)) + coord_flip() + labs(y = NULL, x = NULL, fill = "Number of Videos") + scale_fill_continuous(high = "dark red", low = "dark blue")
bot8Temp <- ggplot(tail(temp1, 8), aes(x = reorder(Channel, Freq), y = Freq)) + geom_col(aes(fill = Freq)) + coord_flip() + labs(y = NULL, x = NULL, fill = "Number of Videos") + scale_fill_continuous(high = "dark red", low = "dark blue")
tempGG
```


(End of Day 1)
